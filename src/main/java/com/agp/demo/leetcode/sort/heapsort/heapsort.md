**堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；\
或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图**
***

![image](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217182750011-675658660.png)
***
同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子
![image](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161217182857323-2092264199.png)
***
**该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：**
\
**大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]**

**小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]**
###堆排序的基本思想
####将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。
####将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，
####这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了

###最大堆步骤：
####一、i=0; i<ary.length-1(循环执行ary.length-1次); 
####一、1.标记最后一个值index 。 int lastIndex=ary.length-1-i
####二、 每次从 (int j=lastIndex) until 0 遍历执行 从尾部到头部的最大堆顶建设。 
#####二、1. int jv=ary[j]  if(j%2==0)  j对应的父节点是 int father=ary[j/2-1] 比较j和父节点的值，
#####二、2. if(father<jv)  => swap(ary,j,(j/2-1))
#####二、3. if(j%2=1) j对应的father节点是 int findex=j/2  
#####二、4. if(ary[j]>ary[findex]) -> swap(ary,j,j/2)
#####二、5. if(j==0) ->  swap(ary,0,lastIndex)

### 感觉堆排 断言的感觉。 对固定下标的父节点已经断言位置。 断言数组里面的数据就是一个完美的二叉树

* 本算法优点。每个下标对应的值和父节点比较一次。 
* 如果从中间非子节点开始，则每次要向下探寻自己的两个子节点并比较两次。而且还要判断是否

