package com.agp.demo.juc;

/**
 * Synchronized修饰普通同步方法：锁对象当前实例对象；
 * Synchronized修饰静态同步方法：锁对象是当前的类Class对象；
 * Synchronized修饰同步代码块：锁对象是Synchronized后面括号里配置的对象，这个对象可以是某个对象（xlock），也可以是某个类（Xlock.class）
 * Synchronized修饰对象：锁对象是一个其他实例对象
 *
 *
 * Synchronized不论是修饰方法还是代码块，
 * 都是通过持有修饰 对象的锁 来实现同步
 *
 * 已知对象是存放在堆内存中的，对象大致可以分为三个部分，
 * 分别是
     * 对象头、
 *      对象头是由MarkWord和Klass Point(类型指针)组成
 *      其中Klass Point是是对象指向它的类元数据的指针，
 *      虚拟机通过这个指针来确定这个对象是哪个类的实例，
 *      Mark Word用于存储对象自身的运行时数据。
 *
     * 实例变量
 *          存储的是对象的属性信息，包括父类的属性信息，按照4字节对齐
 *
     * 填充字节
 *          因为虚拟机要求对象字节必须是8字节的整数倍，填充字符就是用于凑齐这个整数倍的
 *
 *
 *  偏向锁
 *  轻量级锁
 *  都是在java6以后对锁机制进行优化时引进的
 *
 *
 *  重量级锁对应的锁标志位是10，存储了指向重量级监视器锁的指针，
 *  在Hotspot中，对象的监视器（monitor）
 *  锁对象由ObjectMonitor对象实现（C++），其跟同步相关的数据结构如下：
 *
 *  ObjectMonitor() {
 *     _count        = 0; //用来记录该对象被线程获取锁的次数
 *     _waiters      = 0;
 *     _recursions   = 0; //锁的重入次数
 *     _owner        = NULL; //指向持有ObjectMonitor对象的线程
 *     _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet
 *     _WaitSetLock  = 0 ;
 *     _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表
 *   }
 *
 * 线程的生命周期存在5个状态，start、running、waiting、blocking和dead
 * 对于一个synchronized修饰的方法(代码块)来说<线程获取Synchronized锁过程中的状态.png>：
 *
 *  1.当多个线程同时访问该方法，那么这些线程会先被放进_EntryList队列，
 *      此时线程处于blocking状态
 *
 *  2.当一个线程获取到了实例对象的监视器（monitor）锁，那么就可以进入running状态，执行方法，
 *      此时，ObjectMonitor对象的_owner指向当前线程，
 *      _count加1表示当前对象锁被一个线程获取
 *
 *  3. 当running状态的线程调用wait()方法，那么当前线程释放monitor对象，进入waiting状态，
 *      ObjectMonitor对象的_owner变为null，_count减1，
 *      同时线程进入_WaitSet队列，直到有线程调用notify()方法唤醒该线程，
 *      则该线程重新获取monitor对象进入_Owner区
 *
 *  4. 如果当前线程执行完毕，那么也释放monitor对象，进入waiting状态，
 *      ObjectMonitor对象的_owner变为null，_count减1
 *
 *      monitorenter  //注意此处，进入同步方法
 *      monitorexit   //注意此处，退出同步方法
 *
 *      为了保证不论是正常执行完毕（第15行）还是异常跳出代码块（第21行）
 *      都能执行monitorexit语句，因此会出现两句monitorexit语句
 *
 *
 * 锁的优化:
 *  1、锁升级
 *      锁的4中状态：
 *          无锁状态、
 *          偏向锁状态、
 *          轻量级锁状态、
 *          重量级锁状态（级别从低到高）
 *
 *  无锁状态--》升级  偏向锁状态
 *  轻量级锁状态--升级》 重量级锁状态
 *
 *
 *   （1）偏向锁：
 *      为什么要引入偏向锁？
 *      大量的研究发现，大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，
 *      因此如果每次都要竞争锁会增大很多没有必要付出的代价，
 *      为了降低获取锁的代价，才引入的偏向锁。
 *
 *      偏向锁的升级：
 *          当线程1访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向的锁的threadID
 *
 *          偏向锁不会主动释放锁：
 *              因此以后线程1再次获取锁的时候，
 *              比较当前线程threadID ==? Java对象头中的threadID(是否一致){
 *                  if(yes):{
 *                      则无需使用CAS来加锁、解锁
 *                  }else:{
 *                      其他线程，如线程2 竞争锁对象，
 *                      而偏向锁不会主动释放因此还是存储的线程1的threadID
 *                      then:
 *                          {
 *                           查看Java对象头中记录的线程1（是否存活 ）{
 *                               if(yes):{
 *                                   立刻查找该线程（线程1）的栈帧信息，
 *                                   如果还是需要 继续 持有这个锁对象
 *                                   then:
 *                                      暂停当前线程1，撤销偏向锁，升级为轻量级锁
 *                                   else:
 *                                      不再使用该锁对象，那么将锁对象状态设为无锁状态，
 *                                      重新偏向新的线程
 *                               }else{
 *                                  那么锁对象被重置为无锁状态，
 *                                  其它线程（线程2）可以竞争将其设置为偏向锁；
 *                               }
 *                           }
 *                          }
 *
 *
 *                  }
 *              }
 *      偏向锁是默认开启的，而且开始时间一般是比应用程序启动慢几秒，
 *      如果不想有这个延迟，那么可以使用
 *      -XX:BiasedLockingStartUpDelay=0；
 *
 *      如果不想要偏向锁，那么可以通过-XX:-UseBiasedLocking = false来设置；
 *
 * （2）轻量级锁
 *    为什么要引入轻量级锁？
 *    轻量级锁考虑的是竞争锁对象的 线程 不多，而且线程 持有锁的时间 也不长的情景
 *
 *    因为阻塞线程需要CPU从用户态转到内核态，代价较大，
 *    如果刚刚阻塞不久这个锁就被释放了，
 *    那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。
 *
 *    轻量级锁什么时候升级为重量级锁？
 *      线程1获取轻量级锁时会先把锁对象的对象头MarkWord复制一份
 *      到线程1的栈帧中创建的用于存储锁记录的空间（称为DisplacedMarkWord），
 *      然后使用CAS把对象头中的内容替换为线程1存储的锁记录（DisplacedMarkWord）的地址；
 *
 *      如果在线程1复制对象头的同时（在线程1CAS之前），
 *      线程2也准备获取锁，复制了对象头到线程2的锁记录空间中，但是在线程2CAS的时候，
 *      发现线程1已经把对象头换了，
 *      线程2的CAS失败，那么线程2就尝试使用自旋锁来等待线程1释放锁。
 *
 *      但是如果自旋的时间太长也不行，因为自旋是要消耗CPU的，
 *      因此自旋的次数是有限制的，比如10次或者100次，
 *      如果自旋次数到了线程1还没有释放锁，或者线程1还在执行，
 *      线程2还在自旋等待，
 *      这时又有一个线程3过来竞争这个锁对象，
 *      那么这个时候轻量级锁就会膨胀为重量级锁。
 *      重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。
 *
 *   *注意：
 *   为了避免无用的自旋，轻量级锁一旦 膨胀为重量级锁就 不会再降级 为轻量级锁了；
 *   偏向锁升级为轻量级锁也不能再降级为偏向锁。
 *   一句话就是锁可以升级不可以降级，
 *   但是 偏向锁状态 可以被重置为 无锁状态
 *
 *
 *2、锁粗化
 *  同步块的作用范围应该尽可能小，仅在共享数据的实际作用域中才进行同步，
 *  这样做的目的是为了使需要同步的操作数量尽可能缩小，
 *  缩短阻塞时间，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。
 *
 *  但是加锁解锁也需要消耗资源，如果存在一系列的连续加锁解锁操作，
 *  可能会导致不必要的性能损耗。
 * 锁粗化就是将多个连续的加锁、
 * 解锁操作连接在一起，扩展成一个范围更大的锁，避免频繁的加锁解锁操作
 *
 * 3、锁消除
 *  Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，
 *  通过对运行上下文的扫描，经过逃逸分析，
 *  去除 不可能存在共享资源竞争的锁，
 *  通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间
 *
 *
 *
 *以上是synchronized的特点
 *
 * synchronized和lock区别：
 * 区别如下：
 * 来源：
 *  lock是一个接口，而synchronized是java的一个关键字，synchronized是内置的语言实现；
 *异常是否释放锁：
 *  synchronized在发生异常时候会自动释放占有的锁，因此不会出现死锁；
 *  而lock发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，
 *  可能引起死锁的发生。
 *  （所以最好将同步代码块用try catch包起来，
 *  finally中写入unlock，避免死锁的发生。）
 *
 * 是否响应中断
 *  lock等待锁过程中可以用interrupt来中断等待，
 *  而synchronized只能等待锁的释放，不能响应中断
 *
 *  是否知道获取锁
 * Lock可以通过trylock来知道有没有获取锁，而synchronized不能；
 *
 * Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）
 *
 * 在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，
 * 而当竞争资源非常激烈时（即有大量线程同时竞争），
 * 此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。
 *
 * Java1.6，发生了变化。synchronize在语义上很清晰，可以进行很多优化，
 * 有适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。
 * 导致在Java1.6上synchronize的性能并不比Lock差。
 * 官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地。
 *
 *
 *
 *
 * synchronized使用Object对象本身的wait 、notify、notifyAll调度机制，
 * 而Lock可以使用Condition进行线程之间的调度，
 *Lock lock=new ReentrantLock();
 * Condition condition=lock.newCondition();...condition.await();...condition.signal();
 * condition.signalAll();
 *
 *
 *2种机制的具体区别：
 *  synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。
 *  （1.6 version进行了锁优化，无锁，偏向锁，轻量级锁，重量级锁）
 *      独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。
 *      而在CPU转换线程阻塞时会引起线程上下文切换，
 *      当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。
 *
 *  而Lock用的是乐观锁方式。所谓乐观锁就是，
 *  每次不加锁而是假设没有冲突而去完成某项操作，
 *  如果因为冲突失败就重试，直到成功为止。
 *  乐观锁实现的机制就是CAS操作（Compare and Swap）
 *
 *synchronized和lock用途区别 ：
 *  synchronized原语和ReentrantLock在一般情况下没有什么区别，
 *  但是在非常复杂的同步应用中，请考虑使用ReentrantLock，特别是遇到下面2种需求的时候。
 *
     *  1.某个线程在等待一个锁的控制权的这段时间需要中断
     * 2.需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程
     * 3.具有公平锁功能，每个到来的线程都将排队等候
 *
 *
 * ReentrantLock的lock机制有2种，忽略中断锁和响应中断锁，
 * 这给我们带来了很大的灵活性。
 *  比如：如果A、B 2个线程去竞争锁，A线程得到了锁，B线程等待，
 *  但是A线程这个时候实在有太多事情要处理，就是一直不返回，
 *  B线程可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。
 *  这个时候ReentrantLock就提供了2种机制：可中断/可不中断
 * 第一，B线程中断自己（或者别的线程中断它），但是ReentrantLock不去响应，
 * 继续让B线程等待，你再怎么中断，我全当耳边风（synchronized原语就是如此）；
 * 第二，B线程中断自己（或者别的线程中断它），ReentrantLock处理了这个中断，
 * 并且不再等待这个锁的到来，完全放弃。
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
public class Synchronized区别Lock {
    static Object lock=new Object();
    public static void test(){
        synchronized (lock){

        }
    }
}
