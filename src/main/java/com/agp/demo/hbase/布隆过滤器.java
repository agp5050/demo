package com.agp.demo.hbase;

/**
 * 布隆过滤器由一个长度为N的01数组array组成
 * 首先将数组array每个元素初始设为0
 * 对集合A中的每个元素w
 * 做 K 次哈希  哈希值对N取模获得index
 * 将array数组中的array[index]置为1
 * 最终array变成一个某些元素为1的01数组
 *
 * 布隆过滤器串对任意给定元素w：
 * •w可能存在于集合A中。
 * •w肯定不在集合A中。  （多次哈希计算后，对应的index不全为1，肯定不在这个集合中）
 *
 *
 * 在论文[插图]中证明，当N取K*|A|/ln2时（其中|A|表示集合A元素个数），能保证最佳的误判率
 * 误判率 ==>也就是 过滤器判定元素可能在集合中  但实际 不在集合中的 占比
 *
 *
 * 有了布隆过滤器这样一个存在性判断之后
 * 把集合A的元素按照顺序分成若干个块，每块不超过64KB，
 * 每块内的多个元素都算出一个布隆过滤器串，
 * 多个块的布隆过滤器 组成 索引数据
 *
 * 若结果为可能存在，则读取对应的数据块，判断w是否在数据块中，
 * 若存在则表示w存在于集合A中；
 * 若不存在则继续判断w是否在下一个数据块中。
 *
 * 提前过滤掉很多不必要的数据块 从而节省了大量的磁盘IO
 *
 * 共有3种类型:
 * NONE：关闭布隆过滤器功能
 * ROW：按照rowkey来计算布隆过滤器的二进制串并存储
 * ROWCOL：按照rowkey+family+qualifier这3个字段拼出byte[]来计算布隆过滤器值并存储
 *(如果在查询的时候，Get能指定rowkey、family、qualifier这3个字段，则肯定可以通过布隆过滤器提升性能)
 * (Get中缺少rowkey、family、qualif ier中任何一个字段 则无法通过ROWCOL布隆过滤器查询到)
 *
 * 一般意义上的Scan操作 HBase都没法使用布隆过滤器来提升扫描数据性能
 *
 * 在某些特定场景下，Scan操作同样可以借助布隆过滤器提升性能
 *
 * 前缀：
 * 腾讯团队rowkey是这样设计的
 * rowkey=userid#otherfield
 * 可以把rowkey中固定长度的前缀计算布隆过滤器
 * 这样按照userid来前缀扫描时（前缀固定，所以计算布隆过滤器的Key值也就固定），
 * 同样可以借助布隆过滤器优化性能
 * 有一倍以上的性能提升
 * 对于Get请求，同样可以借助这种前缀布隆过滤器提升性能。
 * 因此，这种设计对Get和基于前缀扫描的Scan都非常友好
 *这个功能已经在HBase 2.x版本上实现
 *
 *
 *
 *
 *
 *
 *
 */
public class 布隆过滤器 {
}
