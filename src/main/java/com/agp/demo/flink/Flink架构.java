package com.agp.demo.flink;

/**
 * Flink Runtime执行引擎，它是一个分布式系统，
 * 能够接受数据流程序并在一台或多台机器上以容错方式执行
 *
 * Flink Runtime执行引擎可以作为YARN（Yet Another Resource Negotiator）
 * 的应用程序在集群上运行，
 * 也可以在Mesos集群上运行，
 * 还可以在单机上运行（这对于调试Flink应用程序来说非常有用）
 *
 * Flink能够自动地确保在发生机器故障或者其他错误时计算能持续进行，
 * 或者在修复bug或进行版本升级后有计划地再执行一次。
 * 。Flink本质上使用容错性数据流，这使得开发人员可以分析持续生成且永远不结束的数据（即流处理）
 *
 * Flink解决了许多问题，比如保证了exactly-once语义和基于事件时间的数据窗口。
 *
 *
 *
 * 典型的传统架构是采用一个中心化的数据库系统，该系统用于存储事务性数据。
 * 换句话说，数据库（SQL或者NoSQL）拥有“新鲜”（或者说“准确”）的数据，
 * 需要新鲜数据的应用程序都依靠数据库实现。分布式文件系统则用来存储不需要经常更新的数据，
 * 它们也往往是大规模批量计算所依赖的数据存储方式。
 *
 但随着大型分布式系统中的计算复杂度不断上升，
 这种架构已经不堪重负。许多公司经常遇到以下问题。
 • 在许多项目中，从数据到达到数据分析所需的工作流程太复杂、太缓慢。
 • 传统的数据架构太单一：
 数据库是唯一正确的数据源，每一个应用程序都需要通过访问数据库来获得所需的数据。
 • 采用这种架构的系统拥有非常复杂的异常问题处理方法。
 当出现异常问题时，很难保证系统还能很好地运行。
 传统架构的另一个问题是，需要通过在大型分布式系统中不断地更新来维持一致的全局状态。

 流处理架构则少了对这方面的要求，只需要维持本地的数据一致性即可

 如何有效地实现流处理架构并从Flink中获益呢？一个常见的做法是
 设置消息传输层和流处理层
  Kafka --- flink
 Kafka具有持久性的好处之一是消息可以重播。
 这个功能使得像Flink这样的处理器能对事件流中的某一部分进行重播和再计算

 在流处理架构中，消息队列（图中以水平圆柱体表示）连接应用程序，
 并作为新的共享数据源；它们取代了从前的大型集中式数据库。
 在本例中，Flink被多个应用程序使用。
 本地化的数据能够根据微服务项目的需要被存储在文件或者数据库中。
 这种流处理架构的另一个好处是，流处理器（例如Flink）还可以保障数据一致性

 流处理架构不需要集中式数据库。
 取而代之的是消息队列，它作为共享数据源，服务于各种不同的消费者。

 图2-4所示的流处理架构设计
 将欺诈检测器的输出发送给外部的消息队列（Kafka或MapR Streams）
 ，再由如Flink这样的流处理器更新数据库，
 而不是直接将输出发送给数据库。
 这使得刷卡行为的数据
 可以通过消息队列被其他服务使用，例如刷卡行为分析器

 上一次刷卡行为的数据被存储在本地数据库中，不会被其他服务访问。
 这样的设计避免了因为增加新的服务而带来的过载风险


 流处理架构并不是玩具：它被用于具有重要使命的系统，
 这些系统要求流处理层和消息传输层具备一些特性。
 许多关键的业务系统依靠跨数据中心的一致性，它们不仅需要高效的流处理层
 ，更需要消息传输层拥有可靠的跨地域复制能力






 *
 *
 *
 */

public class Flink架构 {
}
