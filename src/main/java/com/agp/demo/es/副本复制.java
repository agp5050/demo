package com.agp.demo.es;

/**
 * 数据副本策略：
 *      分片副本使用主从模式。
 *      多个副本中存在一个主副本Primary和多个从副本Secondary。
 *      所有的数据写入操作都进入主副本，
 *      当主副本出现故障无法访问时，系
 *      统从其他从副本中选择合适的副本作为新的主副本。
 *
 *  数据写入的流程如下：
 *      （1）写请求进入主副本节点，节点为该操作分配SN，使用该SN创建UpdateRequest结构。
 *      然后将该UpdateRequest插入自己的prepare list。
 *       （2）主副本节点将携带 SN 的 UpdateRequest 发往从副本节点，
 *       从节点收到后同样插入prepare list，完成后给主副本节点回复一个ACK。
 *       （3）一旦主副本节点收到所有从副本节点的响应，
 *       确定该数据已经被正确写入所有的从副本节点，
 *       此时认为可以提交了，
 *       将此UpdateRequest放入committed list,
 *       committed list向前移动。
 *       （4）主副本节点回复客户端更新成功完成。
 *       对每一个Prepare消息，
 *       主副本节点向从副本节点发送一个commit通知，
 *       告诉它们自己的committed point位置，
 *       从副本节点收到通知后根据指示移动committed point到相同的位置。
 *
 *
 * 数据副本模型:
 *      ES 中的每个索引都会被拆分为多个分片，并且每个分片都有多个副本。
 *      这些副本称为replication group（副本组，与PacificA中的副本组概念一致）
 *      ，并且在删除或添加文档的时候，各个副本必须同步。
 *      否则，从不同副本中读取的数据会不一致。我们把保持分片副本之间的同步，
 *      以及从中读取的过程称为数据副本模型（data replication model）。
 *
 *      ES的数据副本模型基于主备模式（primary-backup model），
 *      主分片是所有索引操作的入口，它负责验证索引操作是否有效。
 *      一旦主分片接受一个索引操作，主分片的副分片也会接受该操作。
 *
 *
 *
 * 写故障处理
 *      ：
 *      写入期间可能会发生很多错误—硬盘损坏、节点离线，或者某些配置错误，
 *      这些错误都可能导致无法在副分片上执行某个操作，
 *      虽然这比较少见，但是主分片必须汇报这些错误信息。
 *
 *      对于主分片自身错误的情况，它所在的节点会发送一个消息到Master节点。
 *      这个索引操作会等待（默认为最多一分钟）Master节点提升一个副分片为主分片。
 *      这个操作会被转发给新的主分片。
 *      注意，Master同样会监控节点的健康，并且可能会主动降级主分片。
 *      这通常发生在主分片所在的节点离线的时候。
 *
 *
 *
 *      对于主分片自身错误的情况，它所在的节点会发送一个消息到Master节点。
 *      这个索引操作会等待（默认为最多一分钟）Master节点提升一个副分片为主分片。
 *      这个操作会被转发给新的主分片。
 *      注意，Master同样会监控节点的健康，
 *      并且可能会主动降级主分片。
 *      这通常发生在主分片所在的节点离线的时候。
 *
 *      在主分片上执行的操作成功后，该主分片必须处理在副分片上潜在发生的错误。
 *      错误发生的原因可能是在副分片上执行操作时发生的错误，
 *      也可能是因为网络阻塞，导致主分片无法转发操作到副分片，
 *      或者副分片无法返回结果给主分片。这些错误都会导致相同的结果：
 *      in-sync replica set中的一个分片丢失一个即将要向用户确认的操作。
 *      为了避免出现不一致，主分片会发送一条消息到Master节点，
 *      要求它把有问题的分片从in-sync replica set中移除。
 *      一旦Master确认移除了该分片，主分片就会确认这次操作。
 *      注意，Master也会指导另一个节点建立一个新的分片副本，以便把系统恢复成健康状态。
 *
 *
 *      在转发请求到副分片时，主分片会使用副分片来验证它是否仍是一个活跃的主分片。
 *      如果主分片因为网络原因（或很长时间的 GC）被隔离，
 *      则在它意识到被降级之前可能会继续处理传入的索引操作。
 *      来自陈旧的主分片的操作将会被副分片拒绝。
 *      当它接收来自副分片的拒绝其请求的响应时，
 *      它将会访问一下主节点，然后就会知道自己已被替换。
 *      最后将操作路由到新的主分片。
 *
 *      如果没有副分片呢？
 *          主节点知道主分片是唯一可用的副本。
 *          因此我们确保主节点不会提升任何其他分片副本（过时的）为主分片，
 *          并且索引到主分片上的任何操作都不会丢失。
 *
 *
 *      基本读取模型：
 *          通过 ID 读取是非常轻量级的操作，
 *          而一个巨大的复杂的聚合查询请求需要消耗大量 CPU和内存资源。
 *          主从模式的一个好处是保证所有的分片副本都是一致的（正在执行的操作例外）。
 *          因此，单个in-sync中的某个副本也可以提供服务。
 *          当一个读请求被协调节点接收，这个节点负责转发它到其他涉及相关分片的节点，
 *          并整理响应结果发送给客户端。
 *          接收用户请求的这个节点称为协调节点。
 *
 *          基本流程如下：
 *              （1）把读请求转发到相关分片。
 *              注意，因为大多数搜索都会发送到一个或多个索引，
 *              通常需要从多个分片中读取，每个分片都保存这些数据的一部分。
 *
 *              （2）从副本组中选择一个相关分片的活跃副本。
 *              它可以是主分片或副分片。
 *              默认情况下， ES会简单地循环遍历这些分片。
 *
 *              （3）发送分片级的读请求到被选中的副本。
 *
 *              （4）合并结果并给客户端返回响应。
 *              注意，针对通过ID查找的get请求，
 *              会跳过这个步骤，因为只有一个相关的分片。
 *
 *         读故障处理：
 *              当分片不能响应一个读请求时，协调节点会从副本组中选择另一个副本，将请求转发给它。
 *
 *              没有可用的分片副本会导致重复的错误。
 *              在某些情况下，例如，_search,ES 倾向于尽早响应，
 *              即使只有部分结果，也不等待问题被解决
 *              （可以在响应结果的_shards字段中检查本次结果是完整的还是部分的）。
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
public class 副本复制 {
}
