package com.agp.demo.es;

/**
 * 有若干节点正在启动，
 * 集群启动的第一件事是
 * 从已知的活跃机器列表中选择一个作为主节点，
 * 选主之后的流程由主节点触发。
 *
 * ES的选主算法是基于Bully算法的改进，主要思路是对节点ID排序，
 * 取 ID值最大 的节点作为Master，每个节点都运行这个流程。
 *  非常简单
 * 先确定唯一的、大家公认的主节点，
 * 再想办法把最新的机器元数据复制到选举出的主节点上。
 *
 * 基于节点ID排序的简单选举算法有三个附加约定条件：
 *      （1）参选人数需要过半，达到 quorum（多数）后就选出了临时的主。
 *             举个例子，集群有5台主机，节点ID分别是1、2、3、4、5。
 *             当产生网络分区或节点启动速度差异较大时，节点1看到的节点列表是1、2、3、4，选出4；
 *             节点2看到的节点列表是2、3、4、5，选出5。
 *             结果就不一致了，由此产生下面的第二条限制。
 *      （2）得票数需过半。某节点被选为主节点，必须判断加入它的节点数过半，
 *      才确认Master身份。解决第一个问题。
 *      （3）当探测到节点离开事件时，必须判断当前节点数是否过半。
 *          如果达不到 quorum，则放弃Master身份，重新加入集群。
 *          如果不这么做，则设想以下情况：
 *              假设5台机器组成的集群产生网络分区，2台一组，3台一组，
 *              产生分区前，Master位于2台中的一个，
 *              此时3台一组的节点会重新并成功选取Master，产生双主，俗称脑裂。
 *
 *          集群并不知道自己共有多少个节点，quorum值从配置中读取，我们需要设置配置项：
 *              discovery.zen.minimum_master_nodes
 *
 *
 *
 *
 *
 *
 *
 *
 */
public class 选举主节点 {
}
